/*
 * Copyright 1996-2023 Cyberbotics Ltd.
 * Pham Anh Minh 2021602956
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Description:   Autonoumous vehicle controller example
 */

//Lộc started here ====================================================================================================//
// ===================================================================================================================//
// ==================================================================================================================//

#include <webots/camera.h> 			// Điều khiển camera.
#include <webots/device.h> 			// Điều khiển các thiết bị chung của robot.
#include <webots/display.h> 			// Điều khiển màn hình hiển thị.
#include <webots/gps.h> 			// Điều khiển hệ thống định vị GPS.
#include <webots/keyboard.h>			// Điều khiển bàn phím.
#include <webots/lidar.h>			// Điều khiển cảm biến laser LiDAR.
#include <webots/robot.h>			// Điều khiển chức năng chung của robot.
#include <webots/vehicle/driver.h>		//  Điều khiển phương tiện tự động.
#include <math.h>				// Cung cấp các hàm toán học.
#include <stdio.h>				// Dùng để nhập/xuất dữ liệu (ví dụ: printf).
#include <string.h>				// Xử lý chuỗi ký tự.

// to be used as array indices
enum { X, Y, Z };				// Enum: Định nghĩa một enum với các giá trị X, Y, Z đại diện cho các tọa độ 3D (trục X, Y, Z).

#define TIME_STEP 50				// TIME_STEP: Khoảng thời gian (50ms) giữa các bước điều khiển.
#define UNKNOWN 99999.99			// UNKNOWN: Giá trị đại diện cho trạng thái không xác định.

// Line following PID
#define KP 0.25					// Hằng số PID: Đây là các hằng số điều chỉnh cho bộ điều khiển PID (tỉ lệ KP, tích phân KI, vi phân KD), được dùng trong điều khiển đường đi 								của robot.
#define KI 0.006
#define KD 2

bool PID_need_reset = false;			// Biến PID_need_reset: Một biến boolean (kiểu bool) để kiểm tra xem có cần phải reset bộ điều khiển PID hay không.

// Size of the yellow line angle filter
#define FILTER_SIZE 3				// FILTER_SIZE: Định nghĩa kích thước bộ lọc cho dữ liệu góc của đường màu vàng (trong trường hợp robot theo dõi đường).
	
// enabe various 'features'
bool enable_collision_avoidance = false;	// Điều khiển tính năng tránh va chạm.
bool enable_display = false;			// Điều khiển hiển thị trên màn hình.
bool has_gps = false;				// Kiểm tra xem robot có thiết bị GPS không.
bool has_camera = false;			//  Kiểm tra xem robot có camera không.

// camera
WbDeviceTag camera;				//  Đối tượng camera trong Webots.
int camera_width = -1;				// Chiều rộng của hình ảnh từ camera.
int camera_height = -1;				// chiều cao của hình ảnh từ camera.
double camera_fov = -1.0;			// Góc nhìn của camera (Field of View).

// SICK laser
WbDeviceTag sick;				// Đối tượng cảm biến LiDAR.
int sick_width = -1;				// Số lượng điểm dữ liệu LiDAR thu thập được.
double sick_range = -1.0;			// Phạm vi của cảm biến LiDAR.
double sick_fov = -1.0;				// Góc quét của LiDAR (Field of View).

// speedometer
WbDeviceTag display;				// Đối tượng màn hình hiển thị trong Webots.
int display_width = 0;				// Kích thước màn hình hiển thị.
int display_height = 0;
WbImageRef speedometer_image = NULL;		// Hình ảnh của đồng hồ tốc độ.

// GPS
WbDeviceTag gps;				//  Đối tượng GPS.
double gps_coords[3] = {0.0, 0.0, 0.0};		//  Mảng lưu tọa độ GPS (X, Y, Z).
double gps_speed = 0.0;				// Tốc độ đo được từ GPS.

// misc variables
double speed = 0.0;				// speed: Tốc độ của xe.
double steering_angle = 0.0;			// steering_angle: Góc lái.
int manual_steering = 0;			// manual_steering: Chế độ lái bằng tay.
bool autodrive = true;				// autodrive: Chế độ lái tự động (true: bật, false: tắt).

void print_help() {
  printf("You can drive this car!\n");
  printf("Select the 3D window and then use the cursor keys to:\n");
  printf("[LEFT]/[RIGHT] - steer\n");
  printf("[UP]/[DOWN] - accelerate/slow down\n");
}
	// Hàm print_help: Hiển thị hướng dẫn điều khiển xe. Người dùng có thể dùng các phím mũi tên để lái và tăng/giảm tốc.

void set_autodrive(bool onoff) {
  if (autodrive == onoff)
    return;
  autodrive = onoff;
  switch (autodrive) {
    case false:
      printf("switching to manual drive...\n");
      printf("hit [A] to return to auto-drive.\n");
      break;
    case true:
      if (has_camera)
        printf("switching to auto-drive...\n");
      else
        printf("impossible to switch auto-drive on without camera...\n");
      break;
  }
}
	// Hàm set_autodrive: Bật hoặc tắt chế độ lái tự động. Nếu tắt chế độ tự động, nó chuyển sang chế độ lái bằng tay, và ngược lại.

// set target speed
void set_speed(double kmh) {
  // max speed
  if (kmh > 250.0)
    kmh = 250.0;

  speed = kmh;

  printf("setting speed to %g km/h\n", kmh);
  wbu_driver_set_cruising_speed(kmh);
}
	// Hàm set_speed: Thiết lập tốc độ cho xe (giới hạn tối đa 250 km/h). Hàm này in ra tốc độ hiện tại và sử dụng hàm Webots để đặt tốc độ tự động.

// positive: turn right, negative: turn left
void set_steering_angle(double wheel_angle) {
  // limit the difference with previous steering_angle
  if (wheel_angle - steering_angle > 0.1)
    wheel_angle = steering_angle + 0.1;
  if (wheel_angle - steering_angle < -0.1)
    wheel_angle = steering_angle - 0.1;
  steering_angle = wheel_angle;
  // limit range of the steering angle
  if (wheel_angle > 0.5)
    wheel_angle = 0.5;
  else if (wheel_angle < -0.5)
    wheel_angle = -0.5;
  wbu_driver_set_steering_angle(wheel_angle);
}
	// Hàm set_steering_angle: Điều chỉnh góc lái của xe, với giới hạn góc lái là -0.5 đến 0.5.

// Quý started here ===================================================================================================//
// ===================================================================================================================//
// ==================================================================================================================//

//Hàm điều chỉnh góc lái thủ công bằng bàn phím dựa trên sự thay đổi của inc (tăng hoặc giảm)
void change_manual_steer_angle(int inc) {
  set_autodrive(false); 						//false = chế độ lái thủ công

  double new_manual_steering = manual_steering + inc; 			//Tính toán góc lái mới dựa vào inc
  if (new_manual_steering <= 25.0 && new_manual_steering >= -25.0) {	//Đảm bảo không vượt quá ngưỡng [-25, 25]
    manual_steering = new_manual_steering;				//Cập nhật giá trị góc lái mới
    set_steering_angle(manual_steering * 0.02);				//Thông sô góc lái mới để in ra màn hình
  }									// 0.02 (một hệ số quy đổi từ góc lái thủ công sang góc bánh xe)

  if (manual_steering == 0)						//Nếu góc lái = 0, xe đi thẳng
    printf("going straight\n");
  else
    printf("turning %.2f rad (%s)\n", steering_angle, steering_angle < 0 ? "left" : "right");	//In ra thông tin
}

void check_keyboard() {
  int key = wb_keyboard_get_key();		//Lấy phím bấm từ bàn phím
  switch (key) {	
    case WB_KEYBOARD_UP:			//Lấy phím lên, mỗi lần nhấn +5km/s
      set_speed(speed + 5.0);
      break;
    case WB_KEYBOARD_DOWN:			//Tương tự là phím xuống
      set_speed(speed - 5.0);
      break;
    case WB_KEYBOARD_RIGHT:			//Lấy phím sang phải
      change_manual_steer_angle(+1);		//Mỗi lần nhấn gọi hàm change_manual_steer_angle()
      break;
    case WB_KEYBOARD_LEFT:
      change_manual_steer_angle(-1);		//Tương tự là phím sang trái
      break;
    case 'A':					//Phím A để chuyển sang chế độ lái autodriver
      set_autodrive(true);
      break;
  }
}

//Tính toán sự khác biệt màu sắc giữa 2 màu (RGB)
int color_diff(const unsigned char a[3], const unsigned char b[3]) {
  int i, diff = 0;
  for (i = 0; i < 3; i++) {
    int d = a[i] - b[i];
    diff += d > 0 ? d : -d;
  }
  return diff;
}

//Phân tích ảnh từ camera
double process_camera_image(const unsigned char *image) {
  int num_pixels = camera_height * camera_width;  	// tổng số pixes của 1 ảnh
  const unsigned char REF[3] = {95, 187, 203};    	// thang màu vàng
  int sumx = 0;                                   	// tổng vị trí xuất hiện các pixel màu vàng
  int pixel_count = 0;                            	// số lượng xuất hiện pixel màu vàng

  const unsigned char *pixel = image;
  int x;
  for (x = 0; x < num_pixels; x++, pixel += 4) {	//Vòng lặp so sánh từng pixel với màu vàng xem độ khác biệt
    if (color_diff(pixel, REF) < 30) {
      sumx += x % camera_width;
      pixel_count++;  // count yellow pixels
    }							
  }									


  if (pixel_count == 0)
    return UNKNOWN;					//Nếu không có pixel màu vàng return UNKNOWN
							//Nếu có return góc lệch của màu vàng so với tâm camera
  return ((double)sumx / pixel_count / camera_width - 0.5) * camera_fov; 
}

// Lọc ảnh bằng cách lấy góc của ảnh hiện tại tính trung bình với 1 vài góc của ảnh trước đó
double filter_angle(double new_value) {
  static bool first_call = true;
  static double old_value[FILTER_SIZE];			
  int i;

  if (first_call || new_value == UNKNOWN) {  
    first_call = false;
    for (i = 0; i < FILTER_SIZE; ++i)
      old_value[i] = 0.0;
  } else {  // shift old values
    for (i = 0; i < FILTER_SIZE - 1; ++i)
      old_value[i] = old_value[i + 1];
  }

  if (new_value == UNKNOWN)
    return UNKNOWN;
  else {
    old_value[FILTER_SIZE - 1] = new_value;
    double sum = 0.0;
    for (i = 0; i < FILTER_SIZE; ++i)
      sum += old_value[i];
    return (double)sum / FILTER_SIZE;
  }
}

//Hàm này xử lý dữ liệu từ cảm biến SICK (cảm biến lidar) để xác định góc và khoảng cách của chướng ngại vật.
double process_sick_data(const float *sick_data, double *obstacle_dist) {
  const int HALF_AREA = 20;  	//kiểm tra khoảng cách trong khoảng [-20, 20] so với tâm cảm biến
  int sumx = 0;
  int collision_count = 0;
  int x;
  *obstacle_dist = 0.0;
  for (x = sick_width / 2 - HALF_AREA; x < sick_width / 2 + HALF_AREA; x++) {
    float range = sick_data[x];
    if (range < 20.0) {
      sumx += x;
      collision_count++;
      *obstacle_dist += range;
    }
  }

  if (collision_count == 0)	//Nếu không có chướng ngại vật return UNKNOWN
    return UNKNOWN;

  *obstacle_dist = *obstacle_dist / collision_count;
  return ((double)sumx / collision_count / sick_width - 0.5) * sick_fov;
}				//Nếu có chướng ngại vật, return góc lệch vị trí chướng ngại vật so với tâm cảm biến

//Hàm tạo giao diện hiển thị tốc độ của robot
void update_display() {
  const double NEEDLE_LENGTH = 50.0;

  // display background
  wb_display_image_paste(display, speedometer_image, 0, 0, false);

  // draw speedometer needle
  double current_speed = wbu_driver_get_current_speed();
  if (isnan(current_speed))
    current_speed = 0.0;
  double alpha = current_speed / 260.0 * 3.72 - 0.27;
  int x = -NEEDLE_LENGTH * cos(alpha);
  int y = -NEEDLE_LENGTH * sin(alpha);
  wb_display_draw_line(display, 100, 95, 100 + x, 95 + y);

  // draw text
  char txt[64];
  sprintf(txt, "GPS coords: %.1f %.1f", gps_coords[X], gps_coords[Z]);
  wb_display_draw_text(display, txt, 10, 130);
  sprintf(txt, "GPS speed:  %.1f", gps_speed);
  wb_display_draw_text(display, txt, 10, 140);
}

//Hàm lấy tọa độ và tốc độ hiện tại của GPS
void compute_gps_speed() {
  const double *coords = wb_gps_get_values(gps);
  const double speed_ms = wb_gps_get_speed(gps);
  // store into global variables
  gps_speed = speed_ms * 3.6;  				//Chuyển vận tốc từ m/s sang km/h
  memcpy(gps_coords, coords, sizeof(gps_coords));	//Lưu tọa độ GPS vào biến toàn cục
}

//Hàm này để xe luôn bám theo vạch vàng và cần thay đổi
double applyPID(double yellow_line_angle) {
  static double oldValue = 0.0;
  static double integral = 0.0;

  if (PID_need_reset) {
    oldValue = yellow_line_angle;
    integral = 0.0;
    PID_need_reset = false;
  }

  // anti-windup mechanism
  if (signbit(yellow_line_angle) != signbit(oldValue))
    integral = 0.0;

  double diff = yellow_line_angle - oldValue;

  // limit integral
  if (integral < 30 && integral > -30)
    integral += yellow_line_angle;

  oldValue = yellow_line_angle;
  return KP * yellow_line_angle + KI * integral + KD * diff;
}

// Minh started here ==================================================================================================//
// ===================================================================================================================//
// ==================================================================================================================//

int main(int argc, char **argv) {
  wbu_driver_init();
  /* Đoạn code này đang kiểm tra các thiết bị sẵn có trên robot trong trình mô phỏng cũng như kiểm tra xem 
  các thiết bị nào đang được sử dụng như camera, gps, cảm biến tránh va chạm, trình hiển thị */

  for (int j = 0; j < wb_robot_get_number_of_devices(); ++j) {
    WbDeviceTag device = wb_robot_get_device_by_index(j);
    const char *name = wb_device_get_name(device);
    if (strcmp(name, "Sick LMS 291") == 0)
      enable_collision_avoidance = true;
    else if (strcmp(name, "display") == 0)
      enable_display = true;
    else if (strcmp(name, "gps") == 0)
      has_gps = true;
    else if (strcmp(name, "camera") == 0)
      has_camera = true;
  }

  if (has_camera) {
    camera = wb_robot_get_device("camera"); // tìm -> trả về -> gán vào biến camera một thiết bị có tên "camera" được khai báo tại line 
    wb_camera_enable(camera, TIME_STEP); // bật -> thu thập dữ liệu theo tần xuất thời gian được quy ước từ biến TIME_STEP
    camera_width = wb_camera_get_width(camera); // chụp -> trả về chiều rộng và cao của ảnh theo (pixel) và gán cho 2 biến tương 
    camera_height = wb_camera_get_height(camera);
    camera_fov = wb_camera_get_fov(camera); // trả về trường nhìn của camera
  }

  /* Khi tính năng cảm biến va chạm được bật, hàm wb_robot_get_device sẽ lấy cảm biến lidar "Sick LMS 291" và thực hiện đồng thời 
  3 công việc là lấy độ phân giải ngang cảm biến, dò khoảng cách tối đa, lấy trường nhìn 
  */
  if (enable_collision_avoidance) {
    sick = wb_robot_get_device("Sick LMS 291");
    wb_lidar_enable(sick, TIME_STEP);
    sick_width = wb_lidar_get_horizontal_resolution(sick);
    sick_range = wb_lidar_get_max_range(sick);
    sick_fov = wb_lidar_get_fov(sick);
  }

  // tương tự như trên, đơn giản chỉ là gọi và lưu biến từ thiết bị tên "gps" để nhận và cập nhật dữ liệu
  if (has_gps) {
    gps = wb_robot_get_device("gps");
    wb_gps_enable(gps, TIME_STEP);
  }

  /* kiểm thử thiết bị hiển thị có hoạt động ổn định không, nhưng phân đoạn sử dụng wb_display_image_load chưa hiểu lắm vì đây
  là trích xuất dữ liệu dạng ảnh nhưng thông số đồng hồ vận tốc trên trình hiển thị lại ở dạng gif hoặc animation live.
  */
  if (enable_display) {
    display = wb_robot_get_device("display");
    speedometer_image = wb_display_image_load(display, "speedometer.png");
  }

  /*Nếu camera được khởi động, ngay lập tức sẽ có 2 tác động xảy ra song song. Thứ nhất là tốc độ xe sẽ được khởi động với vận tốc
  duy trì là 50km và thứ 2 là kích hoạt một loạt các hệ thống an toàn của xe*/
  if (has_camera)
    set_speed(50.0);  // km/h
  wbu_driver_set_hazard_flashers(true); // đèn báo nguy hiểm
  wbu_driver_set_dipped_beams(true); // bật đèn chiếu gần
  wbu_driver_set_antifog_lights(true); // đèn chống sương mù
  wbu_driver_set_wiper_mode(SLOW); // chế độ gạt nước (chậm)
  print_help();

  // kích hoạt bàn phím và cho phép hit key trong quá trình mo phỏng
  wb_keyboard_enable(TIME_STEP);

  /* 
  1. tất cả thuật toán về hành vi của xe với môi trường sẽ được mô phỏng một cách liên tục, cứ miễn là mô phòng chưa kết thúc (-1)
  2. check_keyboard được gọi lại mỗi bước mô phỏng nhằm kiểm tra xem có tác động điều khiển từ bàn phím của user trong mô phỏng không
  3. biến tĩnh i là biến đếm các bước của mô phỏng, điều kiện này nhằm kiểm tra sau mỗi khoảng thời gian nhất định (bước nhảy TIME_STEP),
      chương trình sẽ thực hiện một số hành động như thu thập thông tin từ lidar và camera.
  4. Dữ liệu từ lidar ứng đụng dể đo khoảng cách tới vật thể xung quanh và lưu vào biến *sick_data, một ứng dụng từ con trỏ cho thấy 
      khoảng cách giữa xe vào tác nhận môi trường thay đổi liên tục khi di chuyển.
  5. Trình xử lý tự lái là hệ rẽ nhánh đồng thời với các tác vụ riêng biệt đi kèm với các trường hợp riêng biệt: giá trị góc và khoảng
      cách lần lượt giữ tại UNKNOW và 0. Tránh chướng ngại vật và theo dõi vạch vàng, bám vạch vàng khi không có chướng ngại vật, giảm
      tốc độ khi không còn thấy vạch vàng.
  6. Làm mới lại bộ điều khiển PID để tránh lưu lại những sai số trước đó trong quá trình chưa thấy vạch vàng và chuẩn bị cho việc tìm
      kiếm vạch vàng tiếp theo.
  */
  while (wbu_driver_step() != -1) {
    // get user input
    check_keyboard();
    static int i = 0;
    if (i % (int)(TIME_STEP / wb_robot_get_basic_time_step()) == 0) {
      const unsigned char *camera_image = NULL;
      const float *sick_data = NULL;
      if (has_camera)
        camera_image = wb_camera_get_image(camera);
      if (enable_collision_avoidance)
        sick_data = wb_lidar_get_range_image(sick);
      if (autodrive && has_camera) {
        double yellow_line_angle = filter_angle(process_camera_image(camera_image));
        double obstacle_dist;
        double obstacle_angle;
        if (enable_collision_avoidance)
          obstacle_angle = process_sick_data(sick_data, &obstacle_dist);
        else {
          obstacle_angle = UNKNOWN;
          obstacle_dist = 0;
        }

        // avoid obstacles and follow yellow line
        if (enable_collision_avoidance && obstacle_angle != UNKNOWN) {
          // an obstacle has been detected
          wbu_driver_set_brake_intensity(0.0);
          // compute the steering angle required to avoid the obstacle
          double obstacle_steering = steering_angle;
          if (obstacle_angle > 0.0 && obstacle_angle < 0.4)
            obstacle_steering = steering_angle + (obstacle_angle - 0.25) / obstacle_dist;
          else if (obstacle_angle > -0.4)
            obstacle_steering = steering_angle + (obstacle_angle + 0.25) / obstacle_dist;
          double steer = steering_angle;
          // if we see the line we determine the best steering angle to both avoid obstacle and follow the line
          if (yellow_line_angle != UNKNOWN) {
            const double line_following_steering = applyPID(yellow_line_angle);
            if (obstacle_steering > 0 && line_following_steering > 0)
              steer = obstacle_steering > line_following_steering ? obstacle_steering : line_following_steering;
            else if (obstacle_steering < 0 && line_following_steering < 0)
              steer = obstacle_steering < line_following_steering ? obstacle_steering : line_following_steering;
          } else
            PID_need_reset = true;
          // apply the computed required angle
          set_steering_angle(steer);
        } else if (yellow_line_angle != UNKNOWN) {
          // no obstacle has been detected, simply follow the line
          wbu_driver_set_brake_intensity(0.0);
          set_steering_angle(applyPID(yellow_line_angle));
        } else {
          // no obstacle has been detected but we lost the line => we brake and hope to find the line again
          wbu_driver_set_brake_intensity(0.4);
          PID_need_reset = true;
        }
      }

      // update stuff
      if (has_gps)
        compute_gps_speed();
      if (enable_display)
        update_display();
    }

    ++i;
  }

  wbu_driver_cleanup();

  return 0;  // ignored
}
